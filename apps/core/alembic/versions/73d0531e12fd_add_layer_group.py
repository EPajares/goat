"""Add layer group

Revision ID: 73d0531e12fd
Revises: 606f91f79a4e
Create Date: 2025-12-01 09:30:42.216968

"""

from alembic import op
import sqlalchemy as sa
import geoalchemy2
import sqlmodel
from sqlalchemy.sql import text
import json

from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = "73d0531e12fd"
down_revision = "606f91f79a4e"
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "layer_project_group",
        sa.Column("updated_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text(
                "to_char(CURRENT_TIMESTAMP AT TIME ZONE 'UTC', 'YYYY-MM-DD\"T\"HH24:MI:SSOF')::timestamptz"
            ),
            nullable=False,
        ),
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("name", sa.Text(), nullable=False),
        sa.Column("order", sa.Integer(), nullable=False),
        sa.Column("properties", postgresql.JSONB(astext_type=sa.Text()), nullable=True),
        sa.Column("project_id", sa.UUID(), nullable=False),
        sa.Column("parent_id", sa.Integer(), nullable=True),
        sa.ForeignKeyConstraint(
            ["parent_id"], ["customer.layer_project_group.id"], ondelete="CASCADE"
        ),
        sa.ForeignKeyConstraint(
            ["project_id"], ["customer.project.id"], ondelete="CASCADE"
        ),
        sa.PrimaryKeyConstraint("id"),
        schema="customer",
    )
    op.add_column(
        "layer_project",
        sa.Column("layer_project_group_id", sa.Integer(), nullable=True),
        schema="customer",
    )
    # Add order column as nullable first
    op.add_column(
        "layer_project",
        sa.Column("order", sa.Integer(), nullable=True),
        schema="customer",
    )
    op.create_foreign_key(
        None,
        "layer_project",
        "layer_project_group",
        ["layer_project_group_id"],
        ["id"],
        source_schema="customer",
        referent_schema="customer",
        ondelete="CASCADE",
    )
    op.drop_column("layer_project", "group", schema="customer")
    connection = op.get_bind()

    # Update layer_project table order based on project.layer_order
    connection.execute(
        text("""
        UPDATE customer.layer_project lp
        SET "order" = t.pos - 1
        FROM customer.project p,
             LATERAL unnest(p.layer_order) WITH ORDINALITY AS t(val, pos)
        WHERE lp.project_id = p.id
          AND lp.id = t.val
        """)
    )

    # SAFETY NET: valid layers existing in DB but NOT in layer_order array
    # Set their order to 0 so the next step doesn't fail.
    connection.execute(
        text('UPDATE customer.layer_project SET "order" = 0 WHERE "order" IS NULL')
    )

    # Now make order column non-nullable
    op.alter_column("layer_project", "order", nullable=False, schema="customer")

    # Update project_public config.layers with order field using Python
    def update_project_public_layers():
        # Fetch all project_public records
        result = connection.execute(
            text(
                "SELECT id, config FROM customer.project_public WHERE config IS NOT NULL"
            )
        )

        for row in result:
            project_public_id, config = row

            if not config or not isinstance(config, dict):
                continue

            layers = config.get("layers", [])
            project_config = config.get("project", {})
            layer_order = project_config.get("layer_order", [])

            if not layers:
                continue

            # Create order mapping from layer_order array
            order_map = {}
            for index, layer_id in enumerate(layer_order):
                try:
                    # Convert to int since layer IDs might be stored as strings in layer_order
                    layer_id_int = (
                        int(layer_id) if isinstance(layer_id, str) else layer_id
                    )
                    order_map[layer_id_int] = index
                except (ValueError, TypeError):
                    continue

            # Update each layer with order field
            updated_layers = []
            for layer in layers:
                if not isinstance(layer, dict):
                    updated_layers.append(layer)
                    continue

                layer_copy = layer.copy()
                layer_id = layer_copy.get("id")

                if layer_id is not None:
                    try:
                        layer_id_int = int(layer_id)
                        # Set order based on position in layer_order, default to 0
                        layer_copy["order"] = order_map.get(layer_id_int, 0)
                    except (ValueError, TypeError):
                        layer_copy["order"] = 0
                else:
                    layer_copy["order"] = 0

                updated_layers.append(layer_copy)

            # Sort layers by order for consistent output
            updated_layers.sort(key=lambda x: (x.get("order", 999999), x.get("id", 0)))

            # Update config with new layers
            updated_config = config.copy()
            updated_config["layers"] = updated_layers

            # Update the database record
            connection.execute(
                text(
                    "UPDATE customer.project_public SET config = :config WHERE id = :id"
                ),
                {"config": json.dumps(updated_config), "id": project_public_id},
            )

    update_project_public_layers()
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    connection = op.get_bind()

    # Remove order field from project_public config.layers using Python
    def remove_order_from_project_public_layers():
        result = connection.execute(
            text(
                "SELECT id, config FROM customer.project_public WHERE config IS NOT NULL"
            )
        )

        for row in result:
            project_public_id, config = row

            if not config or not isinstance(config, dict):
                continue

            layers = config.get("layers", [])

            if not layers:
                continue

            # Remove order field from each layer
            updated_layers = []
            for layer in layers:
                if isinstance(layer, dict):
                    layer_copy = layer.copy()
                    layer_copy.pop("order", None)  # Remove order field if it exists
                    updated_layers.append(layer_copy)
                else:
                    updated_layers.append(layer)

            # Update config with modified layers
            updated_config = config.copy()
            updated_config["layers"] = updated_layers

            # Update the database record
            connection.execute(
                text(
                    "UPDATE customer.project_public SET config = :config WHERE id = :id"
                ),
                {"config": json.dumps(updated_config), "id": project_public_id},
            )

    remove_order_from_project_public_layers()

    op.add_column(
        "layer_project",
        sa.Column("group", sa.TEXT(), autoincrement=False, nullable=True),
        schema="customer",
    )
    op.drop_constraint(None, "layer_project", schema="customer", type_="foreignkey")
    op.drop_column("layer_project", "order", schema="customer")
    op.drop_column("layer_project", "layer_project_group_id", schema="customer")
    op.drop_table("layer_project_group", schema="customer")
    # ### end Alembic commands ###
